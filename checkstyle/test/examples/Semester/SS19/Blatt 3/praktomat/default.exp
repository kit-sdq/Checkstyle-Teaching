# Set timeout, prompt, etc. 
# Please adapt this.
set standard_timeout 15
set startup_timeout 5
set prompt "praktomat>"
set answer ""
set exit_cmd "quit"
#set java "/praktomat/bin/java"
set java "/usr/bin/java"
#set program "PROGRAM"
set program "Shell"

# Don't change this
set timeout $standard_timeout
# If we haven't read the right prompt in PROGRAM_start, it doesn't
# make sense to do any other test.
set prompt_error 0

# Load a program
proc PROGRAM_load { arg } {
    #
}

# Start program and wait for prompt
proc PROGRAM_start {} {
    # it is impossible to use <pass> or <fail> in start :-(
    global standard_timeout
    global startup_timeout
    global timeout
    global prompt
    global spawn_id
    global prompt_error
    global java
    global program
    
    # Startup of the java engine needs to much time.
    set timeout $startup_timeout
    spawn $java $program
    
    # Check for prompt
    expect {
	"$prompt" { }
	timeout { 
	    set prompt_error 1
	    send_user "\nFAIL: start "
	    send_user "(timeout with no prompt, expected \"$prompt\")\n"; 
	}
	eof {
	    set prompt_error 1
	    send_user "\nFAIL: start "
	    send_user "(no prompt, expected \"$prompt\")\n" 
	}
    }
    set timeout $standard_timeout
}

# End program
proc PROGRAM_exit {} {
    global exit_cmd
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    if [catch {send "$exit_cmd\n"}] {
	send_user "\n"
	fail "could not send text, is the program running?"
	return
    }
    
    expect "$exit_cmd\r\n"
    
    expect {
        eof     { pass "$exit_cmd" }
	-re "." { 
	    send_user "\n"
	    fail "$exit_cmd (expected end-of-output)" 
	}
    }
}

# Return version
proc PROGRAM_version {} {
    return "unknown"
}

# Functions to just enter data without expecting answers or errors.
# 
# There are two variants:
# 1. ..._enter just expects the data to send
# 2. ..._enter_c has an additional argument: a comment that is printed
#                on succes or failure.
#
proc PROGRAM_enter {expr} {
    PROGRAM_enter_ "$expr" ""
}

proc PROGRAM_enter_c {expr comment} {
    PROGRAM_enter_ "$expr" "\[$comment\]"
}

proc PROGRAM_enter_ {expr comment} {
    global prompt
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Quote the command
    set cmd [QUOTE $expr]

    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	fail "could not send text, is the program running? $comment"
	return
    }

    # Check result
    expect {
	-re "$expr\[\r\n\]+$prompt" { 
	    pass "$expr $comment" 
	}
	-re "\[:\].*\[\r\n\]+$prompt" { 
 	    fail "$expr (got answer, but none expected) $comment" 
 	}
	-re "\[!\].*\[\r\n\]+$prompt" { 
	    send_user "\n"
 	    fail "$expr (got error, but none expected) $comment" 
 	}
	-ex "$prompt" {
	    send_user "\n"
	    fail "$expr (expected nothing) $comment" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\") $comment"; 
	    expect "$prompt" 
	}
    }
}

# Own functions
proc PROGRAM_ignore {expr} {
    PROGRAM_ignore_ "$expr" ""
}

proc PROGRAM_ignore_c {expr comment} {
    PROGRAM_ignore_ "$expr" "\[$comment\]"
}

proc PROGRAM_ignore_ {expr comment} {
    global prompt
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	send_user "\n"
	fail "could not send text, is the program running? $comment"
	return
    }

    # Check result
    expect {
	-ex "$prompt" { 
	    pass "$expr" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\") $comment"; 
	}
    }
}

# Own functions
proc PROGRAM_test {expr result} {
    PROGRAM_test_ "$expr" "$result" ""
}

proc PROGRAM_test_c {expr result comment} {
    PROGRAM_test_ "$expr" "$result" "\[$comment\]"
}

proc PROGRAM_test_ {expr result comment} {
    global prompt
    global answer
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	send_user "\n"
	fail "could not send text, is the program running? $comment"
	return
    }

    # Quote the expected result - remove tcls special chars, like '[','$' that would 
    # be interpreted in the regular expression of the expect cmd
    set quoted [QUOTE $result]
    set cmd [QUOTE $expr]

    # Check result
    expect {
	-re "$cmd\[\r\n \]+$answer *$quoted\[ \r\n\]+$prompt" { 
	    pass "$expr $comment" 
	}
	# 0-many times ':' followed by 1-many newlines and the $prompt
	-re "\[:\].*\[\r\n\]+$prompt" { 
 	    fail "$expr (got wrong answer, expected \"$result\") $comment" 
 	}
	# 0-many times !:' followed by 1-many newlines and the $prompt
	-re "\[!\].*\[\r\n\]+$prompt" { 
	    send_user "\n"
 	    fail "$expr (got error, but expected \"$result\") $comment" 
 	}
	-ex "$prompt" {
	    send_user "\n"
	    fail "$expr (expected \"$result\") $comment" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\") $comment"; 
	    expect "$prompt" 
	}
    }
}

proc PROGRAM_alternative {expr result1 result2} {
    global prompt
    global answer
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	send_user "\n"
	fail "could not send text, is the program running?"
	return
    }

    # Quote the expected result
    set quoted1 [QUOTE $result1]
    set quoted2 [QUOTE $result2]
    # Quote the command
    set cmd [QUOTE $expr]

    # Check result
    expect {
	-re "$cmd\[\r\n \]+$answer *$quoted1\[ \r\n\]+$prompt" { 
	    pass "$expr" 
	}
	-re "$cmd\[\r\n \]+$answer *$quoted2\[ \r\n\]+$prompt" { 
	    pass "$expr" 
	}
	-re "\[:\].*\[\r\n\]+$prompt" { 
 	    fail "$expr (got wrong answer, expected \"$result1\" or \"$result2\")" 
 	}
	-re "\[!\].*\[\r\n\]+$prompt" { 
	    send_user "\n"
 	    fail "$expr (got error, but expected \"$result1\" or \"$result2\")" 
 	}
	-ex "$prompt" {
	    send_user "\n"
	    fail "$expr (expected \"$result1\" or \"$result2\")" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\")"; 
	    expect "$prompt" 
	}
    }
}

proc PROGRAM_regexp {expr result} {
    global prompt
    global answer
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	send_user "\n"
	fail "could not send text, is the program running?"
	return
    }

    # Quote the command
    set cmd [QUOTE $expr]
    set quoted $result

    # Check result
    expect {
	-re "$cmd\[\r\n \]+$answer *$quoted\[ \r\n\]+$prompt" { 
	    pass "$expr" 
	}
	-re "\[:\].*\[\r\n\]+$prompt" { 
 	    fail "$expr (got wrong answer, expected \"$quoted\")" 
 	}
	-re "\[!\].*\[\r\n\]+$prompt" { 
	    send_user "\n"
 	    fail "$expr (got error, but expected \"$quoted\")" 
 	}
	-ex "$prompt" {
	    send_user "\n"
	    fail "$expr (expected \"$quoted\")" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\")"; 
	    expect "$prompt" 
	}
    }
}

proc PROGRAM_error {expr} {
    PROGRAM_error_ "$expr" ""
}

proc PROGRAM_error_c {expr comment} {
    PROGRAM_error_ "$expr" "\[$comment\]"
}

proc PROGRAM_error_ {expr comment} {
    global prompt
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	send_user "\n"
	fail "could not send text, is the program running?"
	return
    }

    # Quote the command
    set cmd [QUOTE $expr]

    # Check result
    expect {
        -re "$cmd\[\r\n\]+Error! .*\[\r\n\]+$prompt" { 
	    pass "$expr" 
	}
        -re "$prompt" {
	    send_user "\n"
	    fail "$expr (expected error message)" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\") $comment"; 
	    expect "$prompt" 
	}
    }
}

proc PROGRAM_write_testfile {path} {
    set file_tail [file tail "$path"]

    if [catch {open "$path" "r"} f] {
        fail "could not open test file $path"

    } else {				
        set source_file [open "$path" "r"]

        if [catch {open "tests/$file_tail" "w+"} fh] {
            file mkdir "tests"
            set fh [open "tests/$file_tail" "w+"]

            while {[gets $source_file line] != -1} {
                puts $fh $line
            }
            close $fh	 

        } else {
            set fh [open "tests/$file_tail" "w+"]

            while {[gets $source_file line] != -1} {
                puts $fh $line
            }
            close $fh		
        }
    }
}


# Own functions
proc PROGRAM_relaxed_test {expr result} {
    PROGRAM_relaxed_test_ "$expr" "$result" ""
}

proc PROGRAM_relaxed_test_c {expr result comment} {
    PROGRAM_relaxed_test_ "$expr" "$result" "\[$comment\]"
}

proc PROGRAM_relaxed_test_ {expr result comment} {
    global prompt
    global answer
    global prompt_error

    # Don't continue if we haven't read the right prompt
    if $prompt_error {
	return
    }
    
    # Send expression and wait for echo
    if [catch {send "$expr\n"}] {
	send_user "\n"
	fail "could not send text, is the program running? $comment"
	return
    }

    # Quote the expected result - remove tcls special chars, like '[','$' that would 
    # be interpreted in the regular expression of the expect cmd
    set quoted [QUOTE $result]
    set cmd [QUOTE $expr]

    # Check result
    expect {
	-re "$cmd\[\r\n \]+$answer *(.*)\[ \r\n\]+$prompt" { 
	    if [CHECK_ignore_whitespace $expect_out(1,string) $result] {
		pass "$expr $comment"
	    } else {
		fail "$expr (expected \"$result\") $comment" 
	    }
	}
	# 0-many times ':' followed by 1-many newlines and the $prompt
	-re "\[:\].*\[\r\n\]+$prompt" { 
 	    fail "$expr (got wrong answer, expected \"$result\") $comment" 
 	}
	# 0-many times !:' followed by 1-many newlines and the $prompt
	-re "\[!\].*\[\r\n\]+$prompt" { 
	    send_user "\n"
 	    fail "$expr (got error, but expected \"$result\") $comment" 
 	}
	-ex "$prompt" {
	    send_user "\n"
	    fail "$expr (expected \"$result\") $comment" 
	}
	timeout { 
	    send_user "\n"
	    fail "$expr (timeout with no prompt, expected \"$prompt\") $comment"; 
	    expect "$prompt" 
	}
    }
}



# remove evil characters
proc QUOTE {buffer} {
    return [NORMALIZE_chars $buffer {[].$^()*+?|[]} {\\&}]
}

# remove all newlines
proc STRIP_newlines {buffer} {
    return [NORMALIZE_chars $buffer {[\n\r]+} { }]
}

# trailing whitespaces
proc TRIM {buffer} {
	return [string trim $buffer]
}

# substitue chars matching $chars with $subst 
# $chars = regex of chars to be substituted
# $norm = regex to substitute - '&' refers to machted chars
proc NORMALIZE_chars {buffer chars subst} {
    regsub -all "$chars" $buffer "$subst" norm_buf

    return $norm_buf
}

# completely ignore all whitespaces including newlines
proc CHECK_ignore_whitespace {buffer result} {
    # substitute spaces, tabs, newlines with nothing 
    # => delete them from input

    set s_buf [STRIP_newlines [QUOTE $buffer]]
    set s_result [STRIP_newlines [QUOTE $result]]

    set norm_buf [TRIM [NORMALIZE_chars $s_buf {[ \t]+} { }]]
    set norm_result [TRIM [NORMALIZE_chars $s_result {[ \t]+} { }]]

#	print "Checking input $norm_buf against $norm_result \n"

    return [string equal $norm_buf $norm_result] 
}

# ignore newlines
# normalize whitespaces ("\ \ \t\ " => "\ ")
proc CHECK_ignore_nl_norm_ws {buffer result} {
    # substitute spaces, tabs, newlines with nothing 
    # => delete them from input
    set s_buf [STRIP_newlines [QUOTE $buffer]]
    set s_result [STRIP_newlines [QUOTE $result]]

     
    set norm_buf [NORMALIZE_chars $s_buf {[ \t]+} { }]
    set norm_result [NORMALIZE_chars $s_result {[ \t]+} { }]

    return [string equal $norm_buf $norm_result] 
}


# Now go and start the program...
PROGRAM_start
